---
tags:
  - not_impl
  - clickhouse
links:
  - https://youtu.be/XKBYYP5k_Uo?si=Dmp_ct9hLCPzSaSc
  - https://blog.duyet.net/2024/06/clickhouse-replicatedreplacingmergetree.html
---

**MergeTree** – это _хранение на основе сегментов (частей)_ с поддержкой упорядочивания данных по первичному ключу и инкрементальных слияний. Основные особенности MergeTree:
- **Первичный ключ и сортировка:** При создании таблицы MergeTree указывается выражение `ORDER BY`, задающее _первичный ключ_ сортировки. Данные в таблице хранятся в отсортированном порядке по этому ключу (лексикографически по сочетанию значений ключевых столбцов) ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%60MergeTree%60%20,%D0%B2%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%20%D0%B8%20%D1%82%D0%BE%D0%BC%20%D0%B6%D0%B5)). Первичный ключ может быть составным (кортеж из нескольких столбцов или выражений).
- **Партиционирование (опционально):** Можно задать выражение `PARTITION BY` для логического разбиения таблицы на разделы (например, по дате). Партиции хранятся раздельно, что облегчает операции с группами данных (например, `ALTER TABLE ... DROP PARTITION` для удаления старых разделов). При этом партиция **не влияет** на порядок внутри нее и на скорость запросов, а служит для удобства управления данными ([MergeTree | ClickHouse Docs](https://clickhouse.com/docs/ru/engines/table-engines/mergetree-family/mergetree#:~:text=,%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BA%D0%BE%D0%B9%20%D0%B2%20%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8%20ORDER%20BY)).
- **Хранение в частях:** Данные физически хранятся в виде множества неизменяемых _частей_ (part). Каждая часть – это набор файлов на диске, содержащих данные определенного подмножества строк таблицы. Внутри части все строки уже отсортированы по ключу. Все столбцы таблицы каждой части вынесены в отдельные файлы (например, `columnName.bin`) и разбиты на сжатые блоки фиксированного размера ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D0%BF%D0%BE%20%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D1%83%20%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0,%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B0%D0%B5%D1%82%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B4%D0%BB%D1%8F%20%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B8%D1%85%20%D1%81%D1%82%D1%80%D0%BE%D0%BA)). Также для каждой части ведутся файлы первичного индекса (`primary.idx`) и меток гранул (`*.mrk`), которые позволяют быстро находить нужные диапазоны внутри части по значению ключа ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D0%A1%D0%B0%D0%BC%20%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D1%87%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BB%D1%8E%D1%87%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20,%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8%2C%20%D0%B0%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%B4%D0%BB%D1%8F%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2)).
- **Первичный индекс:** Первичный индекс MergeTree хранит значение ключа для каждой _N_-й строки (по умолчанию N=8192, задано параметром `index_granularity`) ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D1%81%D1%82%D1%80%D0%BE%D0%BA%D1%83%2C%20%D0%B0%20%D0%BB%D0%B8%D1%88%D1%8C%20%D0%BD%D0%B5%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B,%D0%BA%D0%B5%D1%88%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F)). То есть индекс указывает не на каждую строку, а на блоки строк (гранулы). Это делает индекс компактным – он умещается в память даже для таблиц с триллионами строк ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D1%81%D1%82%D1%80%D0%BE%D0%BA%D1%83%2C%20%D0%B0%20%D0%BB%D0%B8%D1%88%D1%8C%20%D0%BD%D0%B5%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B,%D0%BA%D0%B5%D1%88%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F)). При запросах ClickHouse по индексу определяет диапазоны гранул, которые могут содержать искомые данные, и читает с диска только их, пропуская остальные ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D0%92%20%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%20%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B5%D0%B2%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%20%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D1%8F,%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%B7%D0%B0%20%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D0%BA)) ([MergeTree | ClickHouse Docs](https://clickhouse.com/docs/ru/engines/table-engines/mergetree-family/mergetree#:~:text=%D0%94%D0%BB%D1%8F%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2%20,%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D1%82%20%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)). Такой _skip_-подход значительно ускоряет отбор по первичному ключу. Однако из-за разреженности иногда читаются чуть лишние данные (до 8191 строк на гранулу), поэтому для очень точечных запросов (например, поиск одной конкретной записи по ключу) ClickHouse подходит меньше – он оптимизирован под сканирование больших диапазонов.
- **Неизменяемость данных:** Части в MergeTree _иммутабельны_ – после записи они не модифицируются. Добавление новых данных всегда создает новую часть, а удаление/обновление реализуется созданием новых частей с актуальными данными (либо “пометками удаления”). Старые части затем удаляются при фоновых очистках. Неизменяемость упрощает параллельный доступ: операции SELECT могут снимaть _снимок_ текущего состояния (списка частей) и работать с ним без блокировок, даже если в это время выполняются новые вставки или слияния [[Merge]] ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B2%D1%8B%20,%D1%81%D0%B1%D0%BE%D1%8F%2C%20%D1%82%D0%B0%D0%BA%20%D1%87%D1%82%D0%BE%20%D0%B5%D1%81%D0%BB%D0%B8%20%D0%BC%D1%8B)).
- **LSM-tree подход:** MergeTree схож с LSM-деревьями, но без отдельного memory-буфера и WAL-журнала – вставляемые данные сразу сортируются и записываются как новая часть на диск ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B2%D1%8B%20,%D1%81%D0%B1%D0%BE%D1%8F%2C%20%D1%82%D0%B0%D0%BA%20%D1%87%D1%82%D0%BE%20%D0%B5%D1%81%D0%BB%D0%B8%20%D0%BC%D1%8B)) ([Обзор архитектуры | ClickHouse Docs](https://clickhouse.com/docs/ru/development/architecture#:~:text=%60MergeTree%60%20,%D0%B2%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%20%D0%B8%20%D1%82%D0%BE%D0%BC%20%D0%B6%D0%B5)). Это снижает задержки вставки и упрощает архитектуру, хотя ведет к _усилению записи_ (одни и те же данные при слияниях [[Merge]]могут перезаписываться на диск несколько раз).
![[Pasted image 20250425035039.png]]

В сумме, MergeTree обеспечивает **баланс между скоростью записи и чтения**. Записи идут батчами без индексации каждой отдельной строчки, а чтение ускоряется за счет сортировки и разреженного индекса.

Простой пример создания таблицы MergeTree:

```sql
CREATE TABLE events (
    EventDate Date,
    UserID    UInt64,
    EventType String,
    Value     Float32
) 
ENGINE = MergeTree
PARTITION BY toYYYYMM(EventDate)         -- партиционируем по месяцу
ORDER BY (EventDate, UserID)             -- сортируем по дате и ид пользователя
SETTINGS index_granularity = 8192;       -- размер гранулы по умолчанию
```

В этом примере таблица разделена по месяцам, а строки в каждой партиции упорядочены по дате и идентификатору пользователя. Первичный индекс позволит быстро находить данные по диапазону дат и пользователям.
